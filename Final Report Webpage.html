<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Final Report</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Final Report Webpage_files/libs/clipboard/clipboard.min.js"></script>
<script src="Final Report Webpage_files/libs/quarto-html/quarto.js"></script>
<script src="Final Report Webpage_files/libs/quarto-html/popper.min.js"></script>
<script src="Final Report Webpage_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Final Report Webpage_files/libs/quarto-html/anchor.min.js"></script>
<link href="Final Report Webpage_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Final Report Webpage_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Final Report Webpage_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Final Report Webpage_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Final Report Webpage_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Report</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'dplyr'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:stats':

    filter, lag</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ forcats   1.0.0     ✔ readr     2.1.4
✔ ggplot2   3.5.0     ✔ stringr   1.5.0
✔ lubridate 1.9.3     ✔ tibble    3.2.1
✔ purrr     1.0.2     ✔ tidyr     1.3.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors

Attaching package: 'plotly'


The following object is masked from 'package:ggplot2':

    last_plot


The following object is masked from 'package:stats':

    filter


The following object is masked from 'package:graphics':

    layout



Attaching package: 'psych'


The following objects are masked from 'package:ggplot2':

    %+%, alpha



Attaching package: 'reshape2'


The following object is masked from 'package:tidyr':

    smiths


randomForest 4.7-1.1

Type rfNews() to see new features/changes/bug fixes.


Attaching package: 'randomForest'


The following object is masked from 'package:psych':

    outlier


The following object is masked from 'package:ggplot2':

    margin


The following object is masked from 'package:dplyr':

    combine</code></pre>
</div>
</div>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>For the final project for our STAT 515 class, we were asked to find a dataset and perform a robust advanced analysis on the data. For this project we chose to use breast cancer screening data from the University of Wisconsin [1].&nbsp;This study aims to identify patterns and indicators that could potentially predict the signs of malignant cancerous cells. Through meticulous analysis, the paper investigates various aspects, including a deep dive into the predictor variables and their relationship to each other and the response variable, the creation of various statistical models to predict cancerous cells and then finally a comparison of models to choose the best one. By scrutinizing these factors, this research hopes to make discovering breast cancer in patients easier and earlier. &nbsp;</p>
</section>
<section id="i.-introduction" class="level2">
<h2 class="anchored" data-anchor-id="i.-introduction">i. Introduction</h2>
<p>Why are we doing this, what do we hope to do/lean and why is that important. Description of dataset.</p>
</section>
<section id="ii.-materials-and-methods" class="level2">
<h2 class="anchored" data-anchor-id="ii.-materials-and-methods">ii. Materials and Methods</h2>
<p>The University of Wisconsin breast cancer data from William Wolberg has 699 observations and 10 variables, the first variable represents the ID of the sample and the last column “benornal” represents the classification/response variable (for benign, 4 for malignant).</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   699 obs. of  11 variables:
 $ id              : int  1000025 1002945 1015425 1016277 1017023 1017122 1018099 1018561 1033078 1033078 ...
 $ clumpthickness  : int  5 5 3 6 4 8 1 2 2 4 ...
 $ uniformcellsize : int  1 4 1 8 1 10 1 1 1 2 ...
 $ uniformcellshape: int  1 4 1 8 1 10 1 2 1 1 ...
 $ margadhesion    : int  1 5 1 1 3 8 1 1 1 1 ...
 $ epithelial      : int  2 7 2 3 2 7 2 2 2 2 ...
 $ barenuclei      : chr  "1" "10" "2" "4" ...
 $ blandchromatin  : int  3 3 3 3 3 9 3 3 1 2 ...
 $ normalnucleoli  : int  1 2 1 7 1 7 1 1 1 1 ...
 $ mitoses         : int  1 1 1 1 1 1 1 1 5 1 ...
 $ benormal        : int  2 2 2 2 2 4 2 2 2 2 ...</code></pre>
</div>
</div>
<p>To make the dataset ready for analysis we removed the ID column, checked and removed all rows with missing data changed he response variable values to malignant (4) = 1 and benign (2) = 0.</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Warning: NAs introduced by coercion</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>  clumpthickness  uniformcellsize uniformcellshape     margadhesion 
               0                0                0                0 
      epithelial       barenuclei   blandchromatin   normalnucleoli 
               0               16                0                0 
         mitoses         benormal 
               0                0 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   683 obs. of  10 variables:
 $ clumpthickness  : int  5 5 3 6 4 8 1 2 2 4 ...
 $ uniformcellsize : int  1 4 1 8 1 10 1 1 1 2 ...
 $ uniformcellshape: int  1 4 1 8 1 10 1 2 1 1 ...
 $ margadhesion    : int  1 5 1 1 3 8 1 1 1 1 ...
 $ epithelial      : int  2 7 2 3 2 7 2 2 2 2 ...
 $ barenuclei      : int  1 10 2 4 1 10 10 1 1 1 ...
 $ blandchromatin  : int  3 3 3 3 3 9 3 3 1 2 ...
 $ normalnucleoli  : int  1 2 1 7 1 7 1 1 1 1 ...
 $ mitoses         : int  1 1 1 1 1 1 1 1 5 1 ...
 $ benormal        : int  2 2 2 2 2 4 2 2 2 2 ...
 - attr(*, "na.action")= 'omit' Named int [1:16] 24 41 140 146 159 165 236 250 276 293 ...
  ..- attr(*, "names")= chr [1:16] "24" "41" "140" "146" ...</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code> clumpthickness   uniformcellsize  uniformcellshape  margadhesion  
 Min.   : 1.000   Min.   : 1.000   Min.   : 1.000   Min.   : 1.00  
 1st Qu.: 2.000   1st Qu.: 1.000   1st Qu.: 1.000   1st Qu.: 1.00  
 Median : 4.000   Median : 1.000   Median : 1.000   Median : 1.00  
 Mean   : 4.442   Mean   : 3.151   Mean   : 3.215   Mean   : 2.83  
 3rd Qu.: 6.000   3rd Qu.: 5.000   3rd Qu.: 5.000   3rd Qu.: 4.00  
 Max.   :10.000   Max.   :10.000   Max.   :10.000   Max.   :10.00  
   epithelial       barenuclei     blandchromatin   normalnucleoli 
 Min.   : 1.000   Min.   : 1.000   Min.   : 1.000   Min.   : 1.00  
 1st Qu.: 2.000   1st Qu.: 1.000   1st Qu.: 2.000   1st Qu.: 1.00  
 Median : 2.000   Median : 1.000   Median : 3.000   Median : 1.00  
 Mean   : 3.234   Mean   : 3.545   Mean   : 3.445   Mean   : 2.87  
 3rd Qu.: 4.000   3rd Qu.: 6.000   3rd Qu.: 5.000   3rd Qu.: 4.00  
 Max.   :10.000   Max.   :10.000   Max.   :10.000   Max.   :10.00  
    mitoses          benormal     
 Min.   : 1.000   Min.   :0.0000  
 1st Qu.: 1.000   1st Qu.:0.0000  
 Median : 1.000   Median :0.0000  
 Mean   : 1.603   Mean   :0.3499  
 3rd Qu.: 1.000   3rd Qu.:1.0000  
 Max.   :10.000   Max.   :1.0000  </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
  0   1 
444 239 </code></pre>
</div>
</div>
<p>After cleaning the dataset, we looked at a summary of the statistics for each variable. For our sample there are 444 records that are identified as not being malignant (=0) and 239 records that are identified as being malignant (=1).</p>
<p>We next wanted to identify if there were any patterns amongst the predictor variables in the dataset. First we looked at the correlations, histrograms and scatterplots of the variables using the pairs.panel() function.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final-Report-Webpage_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Some of the variables showed correlations to each other, but none were deemed significant by the corr.test() function. But one thing we did notice was that many of the variables exhibited a right skew with their means larger than their medians. We could potentially log() the variables to make them more uniform.</p>
<section id="logistic-regression-model" class="level3">
<h3 class="anchored" data-anchor-id="logistic-regression-model">Logistic Regression Model</h3>
<p>After cleaning the data, we decided to develop a Logisitic regression model to see if we could develop a model that could be used to predict if a cell was cancerous or not. Because our outcome can only be one of two things (cell is malignant or benign) we should be using a classification model and logistic regression is a simple model which is much easier to set up and train initially than other machine learning models.</p>
<p>For the first model we used the cleaned dataset and all of the variables.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
glm(formula = benormal ~ ., family = binomial, data = df_clean)

Coefficients:
                  Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)      -10.10394    1.17488  -8.600  &lt; 2e-16 ***
clumpthickness     0.53501    0.14202   3.767 0.000165 ***
uniformcellsize   -0.00628    0.20908  -0.030 0.976039    
uniformcellshape   0.32271    0.23060   1.399 0.161688    
margadhesion       0.33064    0.12345   2.678 0.007400 ** 
epithelial         0.09663    0.15659   0.617 0.537159    
barenuclei         0.38303    0.09384   4.082 4.47e-05 ***
blandchromatin     0.44719    0.17138   2.609 0.009073 ** 
normalnucleoli     0.21303    0.11287   1.887 0.059115 .  
mitoses            0.53484    0.32877   1.627 0.103788    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 884.35  on 682  degrees of freedom
Residual deviance: 102.89  on 673  degrees of freedom
AIC: 122.89

Number of Fisher Scoring iterations: 8</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:  glm(formula = benormal ~ ., family = binomial, data = df_clean)

Coefficients:
     (Intercept)    clumpthickness   uniformcellsize  uniformcellshape  
       -10.10394           0.53501          -0.00628           0.32271  
    margadhesion        epithelial        barenuclei    blandchromatin  
         0.33064           0.09664           0.38302           0.44719  
  normalnucleoli           mitoses  
         0.21303           0.53484  

Degrees of Freedom: 682 Total (i.e. Null);  673 Residual
Null Deviance:      884.4 
Residual Deviance: 102.9    AIC: 122.9</code></pre>
</div>
</div>
<p>In this model the variables clumpthickness, margadhesion, barenuclei, blandchromatin were considered the only variables had significant on the response variables with p-values less than .05. The overall model had an AIC of 122.89.</p>
<p>Next, we wanted to create a new model after logging our variables.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
glm(formula = benormal ~ ., family = binomial, data = df_log)

Coefficients:
                 Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)      -9.31304    1.25953  -7.394 1.42e-13 ***
clumpthickness    1.80864    0.59805   3.024  0.00249 ** 
uniformcellsize   0.50056    0.66380   0.754  0.45080    
uniformcellshape  1.26038    0.74379   1.695  0.09016 .  
margadhesion      0.71750    0.39504   1.816  0.06933 .  
epithelial       -0.04541    0.63630  -0.071  0.94310    
barenuclei        0.36117    0.09149   3.948 7.89e-05 ***
blandchromatin    1.49565    0.61321   2.439  0.01473 *  
normalnucleoli    0.48867    0.35560   1.374  0.16938    
mitoses           1.34541    0.74040   1.817  0.06920 .  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 884.35  on 682  degrees of freedom
Residual deviance: 107.02  on 673  degrees of freedom
AIC: 127.02

Number of Fisher Scoring iterations: 8</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:  glm(formula = benormal ~ ., family = binomial, data = df_log)

Coefficients:
     (Intercept)    clumpthickness   uniformcellsize  uniformcellshape  
        -9.31304           1.80864           0.50056           1.26038  
    margadhesion        epithelial        barenuclei    blandchromatin  
         0.71750          -0.04541           0.36117           1.49565  
  normalnucleoli           mitoses  
         0.48867           1.34541  

Degrees of Freedom: 682 Total (i.e. Null);  673 Residual
Null Deviance:      884.4 
Residual Deviance: 107  AIC: 127</code></pre>
</div>
</div>
<p>For this model the variables clumpthickness and barenuclei were considered the only variables had significant on the response variables with p-values less than .05. The overall model had an AIC of 127.02.</p>
<p>Based on the AIC of these two models, the non-logged model performed better. Now lets try and simplify the model.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
glm(formula = benormal ~ clumpthickness + margadhesion + barenuclei + 
    blandchromatin, family = binomial, data = df_clean)

Coefficients:
                Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)    -10.11370    1.03264  -9.794  &lt; 2e-16 ***
clumpthickness   0.81166    0.12585   6.450 1.12e-10 ***
margadhesion     0.43412    0.11403   3.807 0.000141 ***
barenuclei       0.48136    0.08816   5.460 4.76e-08 ***
blandchromatin   0.70154    0.15196   4.616 3.90e-06 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 884.35  on 682  degrees of freedom
Residual deviance: 125.77  on 678  degrees of freedom
AIC: 135.77

Number of Fisher Scoring iterations: 8</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:  glm(formula = benormal ~ clumpthickness + margadhesion + barenuclei + 
    blandchromatin, family = binomial, data = df_clean)

Coefficients:
   (Intercept)  clumpthickness    margadhesion      barenuclei  blandchromatin  
      -10.1137          0.8117          0.4341          0.4814          0.7015  

Degrees of Freedom: 682 Total (i.e. Null);  678 Residual
Null Deviance:      884.4 
Residual Deviance: 125.8    AIC: 135.8</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Analysis of Deviance Table

Model 1: benormal ~ clumpthickness + uniformcellsize + uniformcellshape + 
    margadhesion + epithelial + barenuclei + blandchromatin + 
    normalnucleoli + mitoses
Model 2: benormal ~ clumpthickness + margadhesion + barenuclei + blandchromatin
  Resid. Df Resid. Dev Df Deviance  Pr(&gt;Chi)    
1       673     102.89                          
2       678     125.78 -5  -22.886 0.0003549 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
</div>
<p>As should be expected, creating a model using only the significant variables was worse at explaining the dataset. We can also conclude that the more complex model is significantly better than the simpler model.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>